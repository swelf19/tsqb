// Code generated by tsqb from devapp/devappstore.go. DO NOT EDIT.
package devapp

import (
	"bytes"

	"fmt"

	"strings"

	"text/template"

	"github.com/swelf19/tsqb/qtypes"

	"github.com/swelf19/tsqb/qfuncs"

	"errors"

	"context"
)

type StoreFields string

var (
	StoreFieldID        StoreFields = "id"
	StoreFieldStoreName StoreFields = "storename"
)

type StoreTableNameType string

var (
	StoreTableName StoreTableNameType = "stores"
)

type StoreCondition struct {
	Table StoreTableNameType
	Field StoreFields
	Func  qtypes.EqualConditions
	Value string
}

func (c StoreCondition) String() string {
	subQueryTemplate, _ := template.New("subquery").Parse("{{.Table}}.{{.Field}} {{.Func}} {{.Value}}")
	queryBuf := new(bytes.Buffer)
	_ = subQueryTemplate.Execute(queryBuf, map[string]string{
		"Table": string(c.Table),
		"Field": string(c.Field),
		"Func":  string(c.Func),
		"Value": c.Value,
	})
	return queryBuf.String()
}

type StoreCondNode struct {
	Conditions []StoreCondition
	WhereLink  qtypes.ComposeMethod
	Nodes      []StoreCondNode
	Not        bool
}

func (cn StoreCondNode) String() string {
	conditions := []string{}
	for _, c := range cn.Conditions {
		conditions = append(conditions, c.String())
	}
	for _, n := range cn.Nodes {
		conditions = append(conditions, n.String())
	}
	condTemplate := "%s"
	if len(conditions) > 1 {
		condTemplate = "(%s)"
	}
	if cn.Not {
		condTemplate = "not " + condTemplate
	}
	return fmt.Sprintf(condTemplate, strings.Join(conditions, fmt.Sprintf(" %s ", cn.WhereLink)))
}

type StoreOrderCond struct {
	Field     StoreFields
	Direction qtypes.OrderDirection
}

func (o StoreOrderCond) String() string {
	if o.Direction == qtypes.OrderAsc {
		return string(o.Field)
	} else {
		return fmt.Sprintf("%s %s", string(o.Field), string(o.Direction))
	}
}

type StoreBuilder struct {
	queryType       qtypes.QueryType
	Fields          []StoreFields
	TableName       StoreTableNameType
	Conditions      []StoreCondNode
	LimitValue      int
	OffsetValue     int
	SelectParams    []interface{}
	InsertParams    []qtypes.InsertParam
	lastPlaceHolder int
	order           []StoreOrderCond
	connection      qtypes.DBConnection
	returningID     bool
}

func (b *StoreBuilder) ResetBuilder() {
	b.Fields = []StoreFields{StoreFieldID, StoreFieldStoreName}
	b.TableName = StoreTableName
	b.Conditions = []StoreCondNode{}
	b.SelectParams = []interface{}{}
	b.InsertParams = []qtypes.InsertParam{}
	b.lastPlaceHolder = 0
	b.LimitValue = 0
	b.OffsetValue = 0
	b.order = []StoreOrderCond{}
	b.returningID = false
}
func NewStoreBuilder() *StoreBuilder {
	b := StoreBuilder{}
	b.ResetBuilder()
	return &b
}
func (b *StoreBuilder) SQL() string {
	switch b.queryType {
	case qtypes.SelectQuery:
		return b.selectQuery()
	case qtypes.InsertQuery:
		return b.insertQuery()
	}
	return "You must init StoreBuilder with one of initial method (Select,Insert,Update,Delete)"
}

func (b StoreBuilder) getWhereString() string {
	WhereClause := ""
	if len(b.Conditions) > 0 {
		condditions := []string{}
		for _, c := range b.Conditions {
			condditions = append(condditions, c.String())
		}
		WhereClause = "where " + strings.Join(condditions, " and ")
	}
	return WhereClause
}

func (b StoreBuilder) getFieldsString() string {
	fields := []string{}
	for _, f := range b.Fields {
		fields = append(fields, string(f))
	}
	return strings.Join(fields, ",")
}

func (b StoreBuilder) getLimitString() string {
	limitString := ""
	if b.LimitValue > 0 {
		limitString = fmt.Sprintf("limit %d", b.LimitValue)
	}
	return limitString
}

func (b StoreBuilder) getOffsetString() string {
	offsetString := ""
	if b.OffsetValue > 0 {
		offsetString = fmt.Sprintf("offset %d", b.OffsetValue)
	}
	return offsetString
}

func (b StoreBuilder) getOrderString() string {
	orderString := ""
	if len(b.order) > 0 {
		orderStrings := []string{}
		for _, o := range b.order {
			orderStrings = append(orderStrings, o.String())
		}
		orderString = fmt.Sprintf("order by %s", strings.Join(orderStrings, ", "))
	}
	return orderString
}

func (b StoreBuilder) selectQuery() string {
	fields := b.getFieldsString()
	WhereClause := b.getWhereString()
	limitString := b.getLimitString()
	offsetString := b.getOffsetString()
	orderString := b.getOrderString()
	baseQuery := fmt.Sprintf("select %s from %s", fields, string(b.TableName))
	directives := []string{
		baseQuery,
		WhereClause,
		orderString,
		offsetString,
		limitString,
	}
	directives = qfuncs.RemoveEmpty(directives)
	query := strings.Join(directives, " ")
	return query
}

func (b StoreBuilder) getInsertPlaceholders() string {
	plc := 1
	placeholders := []string{}
	for range b.InsertParams {
		placeholders = append(placeholders, fmt.Sprintf("$%d", plc))
		plc = plc + 1
	}
	return strings.Join(placeholders, ",")
}

func (b StoreBuilder) getInsertFieldsString() string {
	fields := []string{}
	for _, f := range b.InsertParams {

		fields = append(fields, string(f.Name))
	}
	return strings.Join(fields, ",")
}

func (b StoreBuilder) insertQuery() string {
	fields := b.getInsertFieldsString()
	subQueryTemplate, _ := template.New("subquery").Parse("insert into {{.TableName}}({{.Fields}}) values({{.Placeholders}})")
	placeholders := b.getInsertPlaceholders()
	queryBuf := new(bytes.Buffer)
	_ = subQueryTemplate.Execute(queryBuf, map[string]string{
		"Fields":       fields,
		"TableName":    string(b.TableName),
		"Placeholders": placeholders,
	})
	query := strings.TrimSpace(queryBuf.String())
	if b.returningID {
		query = query + " returning id"
	}
	return query
}

func (b *StoreBuilder) setQueryType(qt qtypes.QueryType) {
	b.ResetBuilder()
	b.queryType = qt
}

func (b *StoreBuilder) Select() *StoreBuilder {
	b.setQueryType(qtypes.SelectQuery)
	return b
}

func (b *StoreBuilder) Insert(u Store) *StoreBuilder {
	b.setQueryType(qtypes.InsertQuery)
	b.InsertParams = u.TSQBSaver()
	return b
}

func (b *StoreBuilder) Limit(limit int) *StoreBuilder {
	b.LimitValue = limit
	return b
}

func (b *StoreBuilder) Offset(offset int) *StoreBuilder {
	b.OffsetValue = offset
	return b
}
func (b *StoreBuilder) ReturningID() *StoreBuilder {
	b.returningID = true
	return b
}
func (b *StoreBuilder) Where(conditions ...StoreCondNode) *StoreBuilder {
	b.Conditions = conditions
	return b
}

func (b *StoreBuilder) ComposeAnd(conditions ...StoreCondNode) StoreCondNode {
	return b.compose(qtypes.WhereAnd, conditions...)
}

func (b *StoreBuilder) ComposeOr(conditions ...StoreCondNode) StoreCondNode {
	return b.compose(qtypes.WhereOr, conditions...)
}

func (b *StoreBuilder) compose(w qtypes.ComposeMethod, conditions ...StoreCondNode) StoreCondNode {
	cn := StoreCondNode{
		Conditions: []StoreCondition{},
		Nodes:      []StoreCondNode{},
		WhereLink:  w,
	}
	for _, node := range conditions {
		if len(node.Conditions) == 1 {
			cn.Conditions = append(cn.Conditions, node.Conditions...)
		} else {
			cn.Nodes = append(cn.Nodes, node)
		}
	}
	return cn
}

func (b *StoreBuilder) OrderByDesc(field StoreFields) *StoreBuilder {
	b.order = append(b.order, StoreOrderCond{Field: field, Direction: qtypes.OrderDesc})
	return b
}

func (b *StoreBuilder) OrderBy(field StoreFields) *StoreBuilder {
	b.order = append(b.order, StoreOrderCond{Field: field, Direction: qtypes.OrderAsc})
	return b
}
func (b *StoreBuilder) CondEqID(compareTo int) StoreCondNode {
	b.lastPlaceHolder = b.lastPlaceHolder + 1
	placeholder := fmt.Sprintf("$%d", b.lastPlaceHolder)
	c := StoreCondition{
		Table: b.TableName,
		Field: StoreFieldID,
		Func:  qtypes.Equal,
		Value: placeholder,
	}
	cn := StoreCondNode{
		Conditions: []StoreCondition{c},
	}
	b.SelectParams = append(b.SelectParams, compareTo)
	return cn
}
func (b *StoreBuilder) CondGtID(compareTo int) StoreCondNode {
	b.lastPlaceHolder = b.lastPlaceHolder + 1
	placeholder := fmt.Sprintf("$%d", b.lastPlaceHolder)
	c := StoreCondition{
		Table: b.TableName,
		Field: StoreFieldID,
		Func:  qtypes.GreaterThan,
		Value: placeholder,
	}
	cn := StoreCondNode{
		Conditions: []StoreCondition{c},
	}
	b.SelectParams = append(b.SelectParams, compareTo)
	return cn
}
func (b *StoreBuilder) CondGteID(compareTo int) StoreCondNode {
	b.lastPlaceHolder = b.lastPlaceHolder + 1
	placeholder := fmt.Sprintf("$%d", b.lastPlaceHolder)
	c := StoreCondition{
		Table: b.TableName,
		Field: StoreFieldID,
		Func:  qtypes.GreaterOrEqualThan,
		Value: placeholder,
	}
	cn := StoreCondNode{
		Conditions: []StoreCondition{c},
	}
	b.SelectParams = append(b.SelectParams, compareTo)
	return cn
}
func (b *StoreBuilder) CondLtID(compareTo int) StoreCondNode {
	b.lastPlaceHolder = b.lastPlaceHolder + 1
	placeholder := fmt.Sprintf("$%d", b.lastPlaceHolder)
	c := StoreCondition{
		Table: b.TableName,
		Field: StoreFieldID,
		Func:  qtypes.LessThan,
		Value: placeholder,
	}
	cn := StoreCondNode{
		Conditions: []StoreCondition{c},
	}
	b.SelectParams = append(b.SelectParams, compareTo)
	return cn
}
func (b *StoreBuilder) CondLteID(compareTo int) StoreCondNode {
	b.lastPlaceHolder = b.lastPlaceHolder + 1
	placeholder := fmt.Sprintf("$%d", b.lastPlaceHolder)
	c := StoreCondition{
		Table: b.TableName,
		Field: StoreFieldID,
		Func:  qtypes.LessOrEqualThan,
		Value: placeholder,
	}
	cn := StoreCondNode{
		Conditions: []StoreCondition{c},
	}
	b.SelectParams = append(b.SelectParams, compareTo)
	return cn
}
func (b *StoreBuilder) CondNeID(compareTo int) StoreCondNode {
	b.lastPlaceHolder = b.lastPlaceHolder + 1
	placeholder := fmt.Sprintf("$%d", b.lastPlaceHolder)
	c := StoreCondition{
		Table: b.TableName,
		Field: StoreFieldID,
		Func:  qtypes.NotEqual,
		Value: placeholder,
	}
	cn := StoreCondNode{
		Conditions: []StoreCondition{c},
	}
	b.SelectParams = append(b.SelectParams, compareTo)
	return cn
}
func (b *StoreBuilder) CondEqStoreName(compareTo string) StoreCondNode {
	b.lastPlaceHolder = b.lastPlaceHolder + 1
	placeholder := fmt.Sprintf("$%d", b.lastPlaceHolder)
	c := StoreCondition{
		Table: b.TableName,
		Field: StoreFieldStoreName,
		Func:  qtypes.Equal,
		Value: placeholder,
	}
	cn := StoreCondNode{
		Conditions: []StoreCondition{c},
	}
	b.SelectParams = append(b.SelectParams, compareTo)
	return cn
}
func (b *StoreBuilder) CondGtStoreName(compareTo string) StoreCondNode {
	b.lastPlaceHolder = b.lastPlaceHolder + 1
	placeholder := fmt.Sprintf("$%d", b.lastPlaceHolder)
	c := StoreCondition{
		Table: b.TableName,
		Field: StoreFieldStoreName,
		Func:  qtypes.GreaterThan,
		Value: placeholder,
	}
	cn := StoreCondNode{
		Conditions: []StoreCondition{c},
	}
	b.SelectParams = append(b.SelectParams, compareTo)
	return cn
}
func (b *StoreBuilder) CondGteStoreName(compareTo string) StoreCondNode {
	b.lastPlaceHolder = b.lastPlaceHolder + 1
	placeholder := fmt.Sprintf("$%d", b.lastPlaceHolder)
	c := StoreCondition{
		Table: b.TableName,
		Field: StoreFieldStoreName,
		Func:  qtypes.GreaterOrEqualThan,
		Value: placeholder,
	}
	cn := StoreCondNode{
		Conditions: []StoreCondition{c},
	}
	b.SelectParams = append(b.SelectParams, compareTo)
	return cn
}
func (b *StoreBuilder) CondLtStoreName(compareTo string) StoreCondNode {
	b.lastPlaceHolder = b.lastPlaceHolder + 1
	placeholder := fmt.Sprintf("$%d", b.lastPlaceHolder)
	c := StoreCondition{
		Table: b.TableName,
		Field: StoreFieldStoreName,
		Func:  qtypes.LessThan,
		Value: placeholder,
	}
	cn := StoreCondNode{
		Conditions: []StoreCondition{c},
	}
	b.SelectParams = append(b.SelectParams, compareTo)
	return cn
}
func (b *StoreBuilder) CondLteStoreName(compareTo string) StoreCondNode {
	b.lastPlaceHolder = b.lastPlaceHolder + 1
	placeholder := fmt.Sprintf("$%d", b.lastPlaceHolder)
	c := StoreCondition{
		Table: b.TableName,
		Field: StoreFieldStoreName,
		Func:  qtypes.LessOrEqualThan,
		Value: placeholder,
	}
	cn := StoreCondNode{
		Conditions: []StoreCondition{c},
	}
	b.SelectParams = append(b.SelectParams, compareTo)
	return cn
}
func (b *StoreBuilder) CondNeStoreName(compareTo string) StoreCondNode {
	b.lastPlaceHolder = b.lastPlaceHolder + 1
	placeholder := fmt.Sprintf("$%d", b.lastPlaceHolder)
	c := StoreCondition{
		Table: b.TableName,
		Field: StoreFieldStoreName,
		Func:  qtypes.NotEqual,
		Value: placeholder,
	}
	cn := StoreCondNode{
		Conditions: []StoreCondition{c},
	}
	b.SelectParams = append(b.SelectParams, compareTo)
	return cn
}
func (u *Store) TSQBScanner() []interface{} {
	return []interface{}{
		&u.ID, &u.StoreName,
	}
}

func (u Store) TSQBSaver() []qtypes.InsertParam {
	params := []qtypes.InsertParam{}
	if u.ID > 0 {
		params = append(params, qtypes.InsertParam{Name: "id", Value: u.ID})
	}
	params = append(params, []qtypes.InsertParam{
		{Name: "storename", Value: u.StoreName},
	}...)
	return params
}
func (b *StoreBuilder) SetDBConnection(connection qtypes.DBConnection) *StoreBuilder {
	b.connection = connection
	return b
}

func (b *StoreBuilder) Fetch() ([]Store, error) {
	if b.connection == nil {
		return nil, errors.New("Required to setup (SetDBConnection) connection before fetching")
	}
	values := []Store{}
	rows, err := b.connection.Query(context.Background(), b.SQL(), b.SelectParams...)
	if err != nil {
		return nil, err
	}
	for rows.Next() {
		v := Store{}
		err = rows.Scan(v.TSQBScanner()...)
		if err != nil {
			return nil, err
		}
		values = append(values, v)
	}
	if rows.Err() != nil {
		return nil, rows.Err()
	}
	return values, nil
}
