// Code generated by tsqb from devapp2/devapp.go. DO NOT EDIT.
package devapp2

import (
	"fmt"

	"strings"

	"github.com/swelf19/tsqb/qtypes"

	"github.com/swelf19/tsqb/qfuncs"

	"errors"

	"context"
)

type userFields struct {
	ID userIDField

	UserName userUserNameField

	LastLog userLastLogField
}

type userSchema struct {
	Fields    userFields
	TableName string
}

var userFieldsValue = userFields{

	ID: userIDField{
		FieldsName: "id",
		TableName:  "users",
	},

	UserName: userUserNameField{
		FieldsName: "username",
		TableName:  "users",
	},

	LastLog: userLastLogField{
		FieldsName: "last_log",
		TableName:  "users",
	},
}

var userSchemaValue = userSchema{
	Fields:    userFieldsValue,
	TableName: "users",
}

type userIDField field

func (f userIDField) GetFieldName() string {
	return f.FieldsName
}

func (f userIDField) GetTableName() string {
	return f.TableName
}

func (f userIDField) GetName() string {
	return f.GetTableName() + "." + f.GetFieldName()
}

type userUserNameField field

func (f userUserNameField) GetFieldName() string {
	return f.FieldsName
}

func (f userUserNameField) GetTableName() string {
	return f.TableName
}

func (f userUserNameField) GetName() string {
	return f.GetTableName() + "." + f.GetFieldName()
}

type userLastLogField field

func (f userLastLogField) GetFieldName() string {
	return f.FieldsName
}

func (f userLastLogField) GetTableName() string {
	return f.TableName
}

func (f userLastLogField) GetName() string {
	return f.GetTableName() + "." + f.GetFieldName()
}

func (f userIDField) Eq(compareTo int) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.Equal,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userIDField) Gt(compareTo int) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.GreaterThan,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userIDField) Gte(compareTo int) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.GreaterOrEqualThan,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userIDField) Lt(compareTo int) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.LessThan,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userIDField) Lte(compareTo int) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.LessOrEqualThan,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userIDField) Ne(compareTo int) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.NotEqual,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userIDField) In(compareTo ...int) qtypes.SimpleCondition {
	comp := make([]interface{}, len(compareTo))
	for i, c := range compareTo {
		comp[i] = c
	}
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.IN,
		CompareTo: comp,
	}
	return cn
}
func (f userUserNameField) Eq(compareTo string) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.Equal,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userUserNameField) Gt(compareTo string) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.GreaterThan,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userUserNameField) Gte(compareTo string) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.GreaterOrEqualThan,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userUserNameField) Lt(compareTo string) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.LessThan,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userUserNameField) Lte(compareTo string) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.LessOrEqualThan,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userUserNameField) Ne(compareTo string) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.NotEqual,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userUserNameField) In(compareTo ...string) qtypes.SimpleCondition {
	comp := make([]interface{}, len(compareTo))
	for i, c := range compareTo {
		comp[i] = c
	}
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.IN,
		CompareTo: comp,
	}
	return cn
}
func (f userLastLogField) Eq(compareTo string) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.Equal,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userLastLogField) Gt(compareTo string) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.GreaterThan,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userLastLogField) Gte(compareTo string) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.GreaterOrEqualThan,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userLastLogField) Lt(compareTo string) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.LessThan,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userLastLogField) Lte(compareTo string) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.LessOrEqualThan,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userLastLogField) Ne(compareTo string) qtypes.SimpleCondition {
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.NotEqual,
		CompareTo: []interface{}{compareTo},
	}
	return cn
}
func (f userLastLogField) In(compareTo ...string) qtypes.SimpleCondition {
	comp := make([]interface{}, len(compareTo))
	for i, c := range compareTo {
		comp[i] = c
	}
	cn := qtypes.SimpleCondition{
		Field:     f,
		Func:      qtypes.IN,
		CompareTo: comp,
	}
	return cn
}

func (b builders) User() userSelectBuilder {
	return userSelectBuilder{
		UserSchema: userSchemaValue,
		schemaName: "users",
	}
}

type userSelectBuilder struct {
	UserSchema userSchema
	conditions qtypes.Condition
	schemaName string
	limit      int
	offset     int
}

func (u userSelectBuilder) Where(conds ...qtypes.Condition) userSelectBuilder {
	newbuilder := u
	newbuilder.conditions = qfuncs.ComposeAnd(conds...)
	return newbuilder
}

func (u userSelectBuilder) Limit(limit int) userSelectBuilder {
	newbuilder := u
	newbuilder.limit = limit
	return newbuilder
}

func (u userSelectBuilder) Offset(offset int) userSelectBuilder {
	newbuilder := u
	newbuilder.offset = offset
	return newbuilder
}

func (u userSelectBuilder) Build() userSelectQuery {
	q := userSelectQuery{
		fields: []qtypes.FieldI{

			u.UserSchema.Fields.ID,

			u.UserSchema.Fields.UserName,

			u.UserSchema.Fields.LastLog,
		},
		userSchema: u.UserSchema,
		tableName:  u.schemaName,
		limit:      u.limit,
		offset:     u.offset,
	}
	if u.conditions != nil {
		q.whereClause = u.conditions.Build()
	}
	return q
}

type userInsertBuilder struct {
	userSchema userSchema
	schemaName string
	data       User
}

func (b userInsertBuilder) Build() userInsertQuery {
	params := []interface{}{}
	for _, f := range b.data.TSQBSaver() {
		params = append(params, f.Value)
	}

	return userInsertQuery{
		schemaName: b.schemaName,
		data:       b.data,
		params:     params,
	}
}

func (b insertBuilders) User(u User) userInsertBuilder {
	return userInsertBuilder{
		userSchema: userSchemaValue,
		schemaName: "users",
		data:       u,
	}
}

func (b updateBuilders) User() userUpdateBuilder {
	return userUpdateBuilder{
		UserSchema: userSchemaValue,
		schemaName: "users",
	}
}

type userUpdateBuilder struct {
	UserSchema   userSchema
	schemaName   string
	updateFields []qtypes.InsertParam
	conditions   qtypes.Condition
}

func (u userUpdateBuilder) Where(conds ...qtypes.Condition) userUpdateBuilder {
	newbuilder := u
	newbuilder.conditions = qfuncs.ComposeAnd(conds...)
	return newbuilder
}

func (b userUpdateBuilder) SetAllFields(u User) userUpdateBuilder {
	b.updateFields = append(
		b.updateFields,
		[]qtypes.InsertParam{

			{Name: "username", Value: u.UserName},

			{Name: "last_log", Value: u.LastLog},
		}...,
	)
	return b.Where(b.UserSchema.Fields.ID.Eq(u.ID))
}

func (b userUpdateBuilder) Build() userUpdateQuery {
	var whereClause qtypes.WhereClause
	params := []interface{}{}
	if b.conditions != nil {
		whereClause = b.conditions.Build()
		params = whereClause.StmtParams
	}
	for _, upd := range b.updateFields {
		params = append(params, upd.Value)
	}
	return userUpdateQuery{
		schemaName:   b.schemaName,
		params:       params,
		whereClause:  whereClause,
		updateFields: b.updateFields,
	}
}

func (b userUpdateBuilder) SetUserName(upd string) userUpdateBuilder {
	b.updateFields = append(
		b.updateFields,
		[]qtypes.InsertParam{
			{Name: "username", Value: upd},
		}...,
	)
	return b
}

func (b userUpdateBuilder) SetLastLog(upd string) userUpdateBuilder {
	b.updateFields = append(
		b.updateFields,
		[]qtypes.InsertParam{
			{Name: "last_log", Value: upd},
		}...,
	)
	return b
}

func (b deleteBuilders) User() userDeleteBuilder {
	return userDeleteBuilder{
		UserSchema: userSchemaValue,
		schemaName: "users",
	}
}

type userDeleteBuilder struct {
	UserSchema userSchema
	schemaName string
	conditions qtypes.Condition
}

func (b userDeleteBuilder) Build() userDeleteQuery {
	var whereClause qtypes.WhereClause
	if b.conditions != nil {
		whereClause = b.conditions.Build()
	}
	return userDeleteQuery{
		schemaName:  b.schemaName,
		whereClause: whereClause,
	}
}
func (u userDeleteBuilder) Where(conds ...qtypes.Condition) userDeleteBuilder {
	newbuilder := u
	newbuilder.conditions = qfuncs.ComposeAnd(conds...)
	return newbuilder
}

type userSelectQuery struct {
	userSchema  userSchema
	fields      []qtypes.FieldI
	tableName   string
	whereClause qtypes.WhereClause
	limit       int
	offset      int
}

func (q userSelectQuery) getFields() string {
	fields := []string{}
	for _, f := range q.fields {
		fields = append(fields, f.GetName())
	}
	return strings.Join(fields, ", ")
}

func (q userSelectQuery) SQL() string {
	sql := fmt.Sprintf(
		"select %[1]s from %[2]s",
		q.getFields(),
		q.tableName,
	)
	if q.whereClause.SqlString != "" {
		sql = sql + " where " + q.whereClause.SqlString
	}
	if q.offset > 0 {
		sql = sql + " offset " + fmt.Sprintf("%d", q.offset)
	}
	if q.limit > 0 {
		sql = sql + " limit " + fmt.Sprintf("%d", q.limit)
	}
	return sql
}

type userInsertQuery struct {
	schemaName string
	data       User
	params     []interface{}
}

func (q userInsertQuery) SQL() string {
	names := []string{}
	placeholders := []string{}
	for plc, f := range q.data.TSQBSaver() {
		placeholders = append(placeholders, fmt.Sprintf("$%d", plc+1))
		names = append(names, f.Name)
	}
	return fmt.Sprintf("insert into %s(%s) values(%s) returning id", q.schemaName, strings.Join(names, ", "), strings.Join(placeholders, ", "))
}
func (q userUpdateQuery) SQL() string {
	updates := []string{}
	plc := q.whereClause.LastPlaceholder
	params := q.whereClause.StmtParams
	for _, upd := range q.updateFields {
		plc++
		params = append(params, upd.Value)
		updates = append(updates, fmt.Sprintf("%s = $%d", upd.Name, plc))
	}
	query := fmt.Sprintf("update %s set %s", q.schemaName, strings.Join(updates, ", "))
	if q.whereClause.SqlString != "" {
		query = query + " where " + q.whereClause.SqlString
	}
	return query
}

type userUpdateQuery struct {
	schemaName   string
	params       []interface{}
	whereClause  qtypes.WhereClause
	updateFields []qtypes.InsertParam
}
type userDeleteQuery struct {
	schemaName  string
	whereClause qtypes.WhereClause
}

func (q userDeleteQuery) SQL() string {
	query := fmt.Sprintf("delete from %s", q.schemaName)
	if q.whereClause.SqlString != "" {
		query = query + " where " + q.whereClause.SqlString
	}
	return query
}

func (q userSelectQuery) Fetch(ctx context.Context, connection qtypes.DBConnection) ([]User, error) {
	if connection == nil {
		return nil, errors.New("Required to setup (SetDBConnection) connection before fetching")
	}
	values := []User{}
	rows, err := connection.Query(ctx, q.SQL(), q.whereClause.StmtParams...)
	if err != nil {
		return nil, fmt.Errorf("fetch User error: %w", err)
	}
	for rows.Next() {
		v := User{}
		err = rows.Scan(v.TSQBScanner()...)
		if err != nil {
			return nil, fmt.Errorf("fetch User error: %w", err)
		}
		values = append(values, v)
	}
	if rows.Err() != nil {
		return nil, fmt.Errorf("fetch User error: %w", rows.Err())
	}
	return values, nil
}

func (u *User) TSQBScanner() []interface{} {
	return []interface{}{

		&u.ID,

		&u.UserName,

		&u.LastLog,
	}
}

func (u User) TSQBSaver() []qtypes.InsertParam {
	params := []qtypes.InsertParam{}
	if u.ID > 0 {
		params = append(params, qtypes.InsertParam{Name: userFieldsValue.ID.FieldsName, Value: u.ID})
	}
	params = append(params, []qtypes.InsertParam{

		{Name: userFieldsValue.UserName.FieldsName, Value: u.UserName},

		{Name: userFieldsValue.LastLog.FieldsName, Value: u.LastLog},
	}...)
	return params
}

func (q userInsertQuery) Exec(ctx context.Context, connection qtypes.DBConnection) (int, error) {
	if connection == nil {
		return 0, errors.New("Required to setup (SetDBConnection) connection before inserting")
	}
	var ret int
	err := connection.QueryRow(ctx, q.SQL(), q.params...).Scan(&ret)
	if err != nil {
		return 0, fmt.Errorf("insert User error: %w", err)
	}
	return ret, nil
}

func (q userUpdateQuery) Exec(ctx context.Context, connection qtypes.DBConnection) error {
	if connection == nil {
		return errors.New("Required to setup (SetDBConnection) connection before updating")
	}
	_, err := connection.Exec(ctx, q.SQL(), q.params...)
	if err != nil {
		return fmt.Errorf("update User error: %w", err)
	}
	return nil
}

func (q userDeleteQuery) Exec(ctx context.Context, connection qtypes.DBConnection) error {
	if connection == nil {
		return errors.New("Required to setup (SetDBConnection) connection before deleteing")
	}
	_, err := connection.Exec(ctx, q.SQL(), q.whereClause.StmtParams...)
	if err != nil {
		return fmt.Errorf("delete User error: %w", err)
	}
	return nil
}
